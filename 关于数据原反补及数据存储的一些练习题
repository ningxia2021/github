#include<stdio.h>
int main() {
	int a = -20;
	int b = 10;
	printf("a+b=%u", a + b);
	return 0;
}

a 原码 : 1000 0000 0000 0000 0000 0000 0001 0100
a 反码 : 1111 1111 1111 1111 1111 1111 1110 1011
a 补码 : 1111 1111 1111 1111 1111 1111 1110 1100
b 补码 : 0000 0000 0000 0000 0000 0000 0000 1010
a + b 在内存中的运算, 就是两数补码相加
a + b :  1111 1111 1111 1111 1111 1111 1111 0110
其源码为补码-1 再取反码
         1111 1111 1111 1111 1111 1111 1111 0101
         1000 0000 0000 0000 0000 0000 0000 1010
结果 应该为 -10


输出什么？
#include <stdio.h>
int main()
{
    char a = -1;
    signed char b = -1;
    unsigned char c = -1;
    printf("a=%d,b=%d,c=%d", a, b, c);
    return 0;
}

 a -> 源码 1000 0000 0000 0000 0000 0000 0000 0001
      补码 1111 1111 1111 1111 1111 1111 1111 1111
      a是char类型 其内存大小为1个字节,八个比特位,这里会出现有效数字的截断 此时a的补码为:1111 1111
      以%d形式打印,其为有符号数,补充其符号位:其补码为1111 1111 1111 1111 1111 1111 1111 1111
      再减去1 得到反码 1111 1111 1111 1111 1111 1111 1111 1110;
      再取反,得到源码  1000 0000 0000 0000 0000 0000 0000 0001;
      这样,十进制a的结果九为-1
 
 b -> 源码 1000 0000 0000 0000 0000 0000 0000 0001
      补码 1111 1111 1111 1111 1111 1111 1111 1111
      b与a一样的道理
 
 c -> 源码 1000 0000 0000 0000 0000 0000 0000 0001
      补码 1111 1111 1111 1111 1111 1111 1111 1111
      这里c也会出现截断:其补码为 1111 1111
      但是其为无符号数,所以系统默认其为正数,为其补全0,直接转化为10禁止数字打印
即    0000 0000 0000 0000 0000 0000 1111 1111
      255


#include <stdio.h>
int main()
{
    char a = -128;
    printf("%u\n", a);
    return 0;
}

a =  1000 0000 0000 0000 0000 0000 1000 0000
补码 1111 1111 1111 1111 1111 1111 1000 0000
a因为其实char类型,内存大小为1字节,所以截断为1000 0000
无符号打印,全面补符号位 
 1111 1111 1111 1111 1111 1111 1000 0000
结果应该是 4294967168


#include <stdio.h>
void main(){
    unsigned int i;
    for (i = 9; i >= 0; i--)
    {
        printf("%u\n", i);
    }
}
